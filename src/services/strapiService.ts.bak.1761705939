// Strapi API Service
// Handles all communication with Strapi CMS

const STRAPI_URL = process.env.REACT_APP_STRAPI_URL || 'http://localhost:1337';
const STRAPI_TOKEN = process.env.REACT_APP_STRAPI_TOKEN;

interface StrapiResponse<T> {
  data: T;
  meta?: any;
}

interface ProductAttributes {
  productId: string;
  title: string;
  tagline?: string;
  description?: string;
  color: string;
  subcategory?: string;
  template: 'standard' | 'analytics' | 'service' | 'video';
  heroMedia?: any;
  gallery?: any;
  sections?: ContentSection[];
  realtimeConfig?: RealtimeConfig;
  active: boolean;
  sortOrder?: number;
  createdAt: string;
  updatedAt: string;
}

interface ContentSection {
  id: number;
  sectionType: 'hero' | 'features' | 'stats' | 'video' | 'gallery' | 'text' | 'custom';
  title?: string;
  layout?: 'full' | 'split' | 'grid' | 'sidebar';
  content?: any;
  media?: any;
  order?: number;
}

interface RealtimeConfig {
  enabled: boolean;
  endpoint?: string;
  refreshInterval?: number;
  authRequired?: boolean;
}

interface StatDataAttributes {
  productId: string;
  metric: string;
  value: string;
  trend?: string;
  timestamp: string;
}

class StrapiService {
  private baseUrl: string;
  private token?: string;
  private cache: Map<string, { data: any; timestamp: number }>;
  private cacheDuration: number = 60000; // 1 minute

  constructor() {
    this.baseUrl = STRAPI_URL;
    this.token = STRAPI_TOKEN;
    this.cache = new Map();
  }

  /**
   * Convert Strapi blocks format to plain text
   */
  private blocksToText(blocks: any): string {
    if (!blocks) return '';
    if (typeof blocks === 'string') return blocks;
    if (!Array.isArray(blocks)) return '';

    return blocks.map(block => {
      if (block.children) {
        return block.children.map((child: any) => child.text || '').join('');
      }
      return '';
    }).join('\n');
  }

  /**
   * Process content sections from Strapi response
   */
  private processSections(sectionsData: any[]): ContentSection[] {
    if (!sectionsData || sectionsData.length === 0) return [];

    return sectionsData.map((item: any) => {
      const section: ContentSection = {
        id: item.id,
        sectionType: item.sectionType,
        title: item.title,
        order: item.order || 0,
      };

      // Process content field based on section type
      if (item.content) {
        if (item.sectionType === 'text') {
          // For text sections, convert blocks to plain text
          section.content = {
            text: this.blocksToText(item.content)
          };
        } else {
          // For other sections, keep blocks as-is for now
          section.content = item.content;
        }
      }

      // Process items field (JSON data for features, stats, etc.)
      if (item.items) {
        // Merge items into content
        section.content = {
          ...section.content,
          ...item.items
        };
      }

      // Process media
      if (item.media?.data) {
        const mediaArray = Array.isArray(item.media.data) ? item.media.data : [item.media.data];
        section.media = mediaArray
          .map((m: any) => this.transformMediaUrl(m))
          .filter((m: any) => m !== null);
      }

      return section;
    });
  }

  /**
   * Make authenticated request to Strapi
   */
  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...(options.headers as Record<string, string>),
    };

    // Add token if available
    if (this.token) {
      headers['Authorization'] = `Bearer ${this.token}`;
    }

    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers,
    });

    if (!response.ok) {
      throw new Error(`Strapi API error: ${response.status} ${response.statusText}`);
    }

    return response.json();
  }

  /**
   * Get cache key
   */
  private getCacheKey(endpoint: string): string {
    return endpoint;
  }

  /**
   * Check if cache is valid
   */
  private isCacheValid(key: string): boolean {
    const cached = this.cache.get(key);
    if (!cached) return false;
    return Date.now() - cached.timestamp < this.cacheDuration;
  }

  /**
   * Fetch all products
   */
  async getAllProducts(): Promise<ProductAttributes[]> {
    const cacheKey = this.getCacheKey('/api/products?populate=*');

    if (this.isCacheValid(cacheKey)) {
      return this.cache.get(cacheKey)!.data;
    }

    const response = await this.request<StrapiResponse<any[]>>(
      '/api/products?populate=*&filters[active][$eq]=true&sort=displayOrder:asc'
    );

    // In Strapi v5, data is flat (no attributes wrapper)
    const products = response.data.map((item: any) => {
      return {
        productId: item.productId,
        title: item.title,
        tagline: item.tagline,
        description: this.blocksToText(item.description),
        color: item.color || '#2563eb',
        subcategory: item.subcategory,
        template: item.template || 'standard',
        active: item.active !== false,
        sortOrder: item.displayOrder || 0,
        createdAt: item.createdAt,
        updatedAt: item.updatedAt,
        heroMedia: item.heroVideo?.data ? this.transformMediaUrl(item.heroVideo.data) : undefined,
        gallery: item.gallery?.data ? item.gallery.data.map((media: any) => this.transformMediaUrl(media)) : undefined,
        sections: this.processSections(item.content_sections?.data || []),
        realtimeConfig: undefined,
      };
    });

    this.cache.set(cacheKey, { data: products, timestamp: Date.now() });
    return products;
  }

  /**
   * Fetch single product by productId
   */
  async getProduct(productId: string): Promise<ProductAttributes | null> {
    const cacheKey = this.getCacheKey(`/api/products/${productId}`);

    if (this.isCacheValid(cacheKey)) {
      return this.cache.get(cacheKey)!.data;
    }

    try {
      // Query with deep population for content sections
      const response = await this.request<StrapiResponse<any[]>>(
        `/api/products?filters[productId][$eq]=${productId}&populate[content_sections][populate]=*&populate[heroVideo]=*&populate[gallery]=*`
      );

      if (response.data.length === 0) {
        return null;
      }

      // In Strapi v5, data is flat (no attributes wrapper)
      const data = response.data[0];

      console.log('Raw product data from Strapi:', data);
      console.log('Content sections data:', data.content_sections);

      // Map Strapi v5 field names to our interface
      const product: ProductAttributes = {
        productId: data.productId,
        title: data.title,
        tagline: data.tagline,
        description: this.blocksToText(data.description),
        color: data.color || '#2563eb',
        subcategory: data.subcategory,
        template: data.template || 'standard',
        active: data.active !== false,
        sortOrder: data.displayOrder || 0,
        createdAt: data.createdAt,
        updatedAt: data.updatedAt,
        // Map heroVideo to heroMedia
        heroMedia: data.heroVideo?.data ? this.transformMediaUrl(data.heroVideo.data) : undefined,
        // Handle gallery if present
        gallery: data.gallery?.data ? data.gallery.data.map((item: any) => this.transformMediaUrl(item)) : undefined,
        // Process and map content_sections to sections
        sections: this.processSections(data.content_sections?.data || []),
        // No realtimeConfig in current schema
        realtimeConfig: undefined,
      };

      console.log('Processed product with sections:', product);
      console.log('Number of sections:', product.sections?.length);

      this.cache.set(cacheKey, { data: product, timestamp: Date.now() });
      return product;
    } catch (error) {
      console.error(`Failed to fetch product ${productId}:`, error);
      return null;
    }
  }

  /**
   * Transform media URL to absolute path
   */
  private transformMediaUrl(mediaData: any) {
    if (!mediaData?.url) return null;

    const url = mediaData.url;
    return {
      url: url.startsWith('http') ? url : `${this.baseUrl}${url}`,
      alternativeText: mediaData.alternativeText,
      caption: mediaData.caption,
      width: mediaData.width,
      height: mediaData.height,
      mime: mediaData.mime,
    };
  }

  /**
   * Fetch live statistics for a product
   */
  async getLiveStats(productId: string): Promise<StatDataAttributes[]> {
    try {
      // First try custom endpoint if available
      const response = await this.request<any>(
        `/api/stats/live/${productId}`
      ).catch(() => null);

      if (response) {
        return response;
      }

      // Fallback to querying stat-data collection
      const fallbackResponse = await this.request<StrapiResponse<any[]>>(
        `/api/stat-datas?filters[productId][$eq]=${productId}&sort=timestamp:desc&pagination[limit]=10`
      );

      // In Strapi v5, data is flat
      return fallbackResponse.data;
    } catch (error) {
      console.error(`Failed to fetch stats for ${productId}:`, error);
      return [];
    }
  }

  /**
   * Subscribe to real-time updates (if product has realtime config)
   */
  async subscribeToUpdates(
    productId: string,
    callback: (stats: StatDataAttributes[]) => void
  ): Promise<() => void> {
    const product = await this.getProduct(productId);

    if (!product?.realtimeConfig?.enabled) {
      console.warn(`Product ${productId} does not have realtime enabled`);
      return () => {};
    }

    const interval = product.realtimeConfig.refreshInterval || 30000;

    // Initial fetch
    const stats = await this.getLiveStats(productId);
    callback(stats);

    // Set up polling
    const intervalId = setInterval(async () => {
      const stats = await this.getLiveStats(productId);
      callback(stats);
    }, interval);

    // Return cleanup function
    return () => clearInterval(intervalId);
  }

  /**
   * Clear cache
   */
  clearCache(productId?: string) {
    if (productId) {
      const keys = Array.from(this.cache.keys()).filter(key => 
        key.includes(productId)
      );
      keys.forEach(key => this.cache.delete(key));
    } else {
      this.cache.clear();
    }
  }

  /**
   * Health check - verify Strapi is accessible
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.request<any>('/api/products?pagination[limit]=1');
      return true;
    } catch (error) {
      console.error('Strapi health check failed:', error);
      return false;
    }
  }
}

// Export singleton instance
export const strapiService = new StrapiService();

// Export types
export type {
  ProductAttributes,
  ContentSection,
  RealtimeConfig,
  StatDataAttributes,
};
